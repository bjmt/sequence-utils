sequenceshuffler
================


Installation
------------

    git clone https://github.com/bjmt/sequenceshuffler
    cd sequenceshuffler
    make

The following binaries are created:

    bin/countfa
    bin/countlets
    bin/seqgen
    bin/shuffler

Run these without any arguments or with the -h flag to see usage.


countfa
-------

Counts the number of characters per sequence in a fasta file. For each sequence,
the name followed by the character count are returned to stdout. The aim is to
count sequence lengths without taking up too much memory. To this end, only one
line is kept in memory at a time. Though this means that if the sequence is not
split up with newlines, the entire thing will be loaded into memory.

Example usage:

    echo ">1\nACAAG\n>2\nGCCCGGTTAT" | bin/countfa

        >1
        5
        >2
        10


countlets
---------

This utility counts the total number of k-lets in the input sequence. Be aware
that the total number of k-lets is n^k, where n is the alphabet length. For use
cases involving memory constraints, providing the sequence alphabet ahead of
time will allow countlets to count k-lets while only needing to load k + 1
letters into memory at a time (at the cost of speed for higher k values). When
the alphabet is provided, it will typically never take up more than a couple MBs
of memory.

Example usage:

    bin/countlets -k 1 -i example/sequence.txt

        A  17384
        C   8081
        G   7583
        T  16952

    bin/countlets -k 1 -a ACGT -i example/sequence.txt

        A  17384
        C   8081
        G   7583
        T  16952


seqgen
------

Create random sequences from any alphabet. Letters can be made up of any
number of characters. Weights can be provided to modify random generation.
If any of the input letters contain spaces, use quotation marks. New letters
are streamed directly to the output, meaning memory usage is independent of
output sequence length.

Example usage:

    bin/seqgen -a A,C,G,T -l 10 -s 11

      CGAACTATTC

    bin/seqgen -a A,C,G,T -l 1000 -s 1 | bin/countlets

      A  246
      C  258
      G  233
      T  263

    bin/seqgen -a "A,B,CD, " -l 10 -s 3

      BCD BBBAAB

    bin/seqgen -a A,C,G,T -l 10 -s 11 -w 1,0.5,0.5,1

      TTAGAATTTT

    bin/seqgen -a A,C,G,T -l 1000 -s 11 -w 1,0.5,0.5,1 | bin/countlets

      A  338
      C  150
      G  169
      T  343


shuffler
--------

Shuffles an input sequence using one of three methods. The default, euler,
preserves exact k-let counts by performing a random Eulerian walk through the
sequence. The implementation is based on the concept proposed by Altschul and
Erickson (1985) as well as the cycle-popping algorithm proposed by Propp and
Wilson (1998) for finding randomised Eulerian paths. One warning regarding this
method: the number of vertices is equal to n^k, where n is the alphabet length.
This means that if trying to shuffle a DNA sequence with k = 15, there will be
over one billion vertices; and every vertex present in the input sequence has
to be walked to the ending vertex, and those walks could potential be quite
long themselves. Once a new Eulerian path has been found, the process is quite
fast regardless of k; but the program may stall for quite some time trying to
find such a path.

The second method, linear, splits the sequence every k letters before shuffling
these around.

See:

    AAACAGATT

After splitting (k = 2):

    AA AC AG AT T
    1  2  3  4  r

The k-let indices are shuffled, and the shuffled sequence reassembled from
the split k-lets by their new index position. Any remainder letters which do
not fit in a full k-let are left at the end.

The third method, markov, works by first getting the total number of all
possible k-lets. Following this, a new sequence (of equal length) is created.
Every new letter is chosen based on the probability of that letter (and the
last k - 1 letters) appearing in a k-let in the original sequence. This results
in a new sequence with similar (but not identical) k-let counts. The idea for
this method of shuffling is discussed by Fitch (1983).

Note: these methods only apply for k > 1. Otherwise, a simple shuffle call is
performed.

Example usage:

  euler shuffling:

    bin/shuffler -i example/sequence.txt -k 2 | bin/countlets

        A  17384
        C   8081
        G   7583
        T  16952

  markov shuffling:

    bin/shuffler -i example/sequence.txt -k 2 -s 1 -m | bin/countlets

        A  17421
        C   8122
        G   7472
        T  16984

  linear + fasta-formatted shuffling:

    echo ">seq\nASCASCASDASCASDASDASC" | bin/shuffler -k 2 -l -s 1 -f

        >seq
        CAASASASSCSCDAASSDDAC

A note on memory usage:

This program is not terribly memory efficient, usually requiring memory several
times the size of the input sequence. This means shuffling billions of
characters is not recommended unless you don't mind letting shuffler take up
several GBs of memory.


References
----------

Altschul, S.F. and Erickson, B.W. (1985). Significance of Nucleotide Sequence
    Alignments: A Method for Random Sequence Permutation That Preserves
    Dinucleotide and Codon Usage. _Molecular Biology and Evolution_, 2(6),
    526-538.

Fitch, W.M. (1983). Random Sequences. _Journal of Molecular Biology_, 163(2),
    171-176.

Propp, J.G. and Wilson, D.W. (1998). How to Get a Perfectly Random Sample from
    a Generic Markov Chain and Generate a Random Spanning Tree of a Directed
    Graph. _Journal of Algorithms_, 27(2), 170-217.

